/* -*- c++ -*- */
/*
 * Copyright (C) 2016  Andy Walls <awalls.cx18@gmail.com>
 *
 * This file was automatically generated by gr_modtool from GNU Radio
 *
 * This file was automatically generated from a template incorporating
 * data input by Andy Walls and subsequently hand edited by Andy Walls.
 * See http://www.gnu.org/licenses/gpl-faq.en.html#GPLOutput .
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include "correction_estimator_ff_impl.h"

namespace gr {
  namespace nwr {

    correction_estimator_ff::sptr
    correction_estimator_ff::make(int inspection_length,
                                  float peak_ref,
                                  float trough_ref,
                                  const std::string &offset_corr_key,
                                  const std::string &scale_corr_key,
                                  bool scale_eob_zero,
                                  const std::string &sob_key,
                                  const std::string &eob_key)
    {
      return gnuradio::get_initial_sptr
        (new correction_estimator_ff_impl(inspection_length,
                                          peak_ref, trough_ref,
                                          offset_corr_key, scale_corr_key,
                                          scale_eob_zero,
                                          sob_key, eob_key));
    }

    correction_estimator_ff_impl::correction_estimator_ff_impl(
                                          int inspection_length,
                                          float peak_ref,
                                          float trough_ref,
                                          const std::string &offset_corr_key,
                                          const std::string &scale_corr_key,
                                          bool scale_eob_zero,
                                          const std::string &sob_key,
                                          const std::string &eob_key)
      : gr::sync_block("correction_estimator_ff",
              gr::io_signature::make(1, 1, sizeof(float)),
              gr::io_signature::make(1, 1, sizeof(float))),
        d_inspection_len(inspection_length),
        d_peak_ref(peak_ref),
        d_trough_ref(trough_ref),
        d_offset_corr_key(pmt::intern(offset_corr_key)),
        d_scale_corr_key(pmt::intern(scale_corr_key)),
        d_sob_key(pmt::intern(sob_key)),
        d_eob_key(pmt::intern(eob_key)),
        d_eob_offset_corr(pmt::from_double(0.0)),
        d_eob_scale_corr(pmt::from_double(scale_eob_zero ? 0.0 : 1.0)),
        d_src_id(pmt::intern(alias())),
        d_tags()
    {
        set_output_multiple(d_inspection_len * 2);
    }

    correction_estimator_ff_impl::~correction_estimator_ff_impl()
    {
    }

    void
    correction_estimator_ff_impl::compute_corrections(const float *in,
                                                      double &offset_corr,
                                                      double &scale_corr)
    {
        // Keeping it simple: just use the max peak and the min trough
        float in_min = in[0];
        float in_max = in[0];

        for (int i = 1; i < d_inspection_len; i++) {
            in_min = std::min(in_min, in[i]);
            in_max = std::max(in_max, in[i]);
        } 

        // (in_max + offset_corr) * scale_corr = d_peak_ref
        // (in_min + offset_corr) * scale_corr = d_trough_ref
        // So after some algebra ...

        offset_corr = (d_trough_ref * in_max - d_peak_ref * in_min)
                      / (d_peak_ref - d_trough_ref);
        scale_corr = (d_peak_ref - d_trough_ref) / (in_max - in_min);
    }

    int
    correction_estimator_ff_impl::work(int noutput_items,
        gr_vector_const_void_star &input_items,
        gr_vector_void_star &output_items)
    {
        const float *in = (const float *) input_items[0];
        float *out = (float *) output_items[0];

        uint64_t nitems_rd = nitems_read(0);

        // Get all the input tags in offset order
        d_tags.clear();
        get_tags_in_range(d_tags, 0, nitems_rd, nitems_rd + noutput_items);
        std::sort(d_tags.begin(), d_tags.end(), tag_t::offset_compare);

        // N.B. we might break badly if SOB and EOB are marked on the same
        // sample offset.  Garbage in, garbage out...

        // Plan to process all of the items in this call to work()
        int idx = noutput_items;
        std::vector<tag_t>::iterator t;
        // Loop through all the tags
        for (t = d_tags.begin(); t != d_tags.end(); ++t) {
            if (pmt::eq(t->key, d_eob_key)) {
                // EOB gets marked with constant correction tags, indicating:
                // offset_corr => 0.0
                // scale_corr => 1.0 or 0.0
                add_item_tag(0, t->offset,
                             d_offset_corr_key,
                             d_eob_offset_corr,
                             d_src_id);
                add_item_tag(0, t->offset,
                             d_scale_corr_key,
                             d_eob_scale_corr,
                             d_src_id);
            } else if (pmt::eq(t->key, d_sob_key)) {
                // SOB
                idx = static_cast<int>(t->offset - nitems_rd);
                if (idx + d_inspection_len - 1 >= noutput_items) {
                    // We don't have all of the samples that we wish to
                    // process, from the start of the burst, in this call to
                    // work().  Bail out, processing all the samples before
                    // this one.  We'll have enough next time.
                    break;
                }

                double offset_corr = 0.0;
                double scale_corr = 1.0;
                compute_corrections(&in[idx], offset_corr, scale_corr);
                add_item_tag(0, t->offset,
                             d_offset_corr_key,
                             pmt::from_double(offset_corr),
                             d_src_id);
                add_item_tag(0, t->offset,
                             d_scale_corr_key,
                             pmt::from_dobule(scale_corr),
                             d_src_id);

                // Plan to process the rest of the items in this call to work()
                idx = noutput_items;
            }
        }

        // Propagate input to output
        memcpy(out, in, sizeof(float) * idx);
        return idx;
    }

  } /* namespace nwr */
} /* namespace gr */

