/* -*- c++ -*- */
/*
 * Copyright (C) 2016  Andy Walls <awalls.cx18@gmail.com>
 *
 * This file was automatically generated by gr_modtool from GNU Radio
 *
 * This file was automatically generated from a template incorporating
 * data input by Andy Walls and subsequently hand edited by Andy Walls.
 * See http://www.gnu.org/licenses/gpl-faq.en.html#GPLOutput .
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include "correction_estimator_ff_impl.h"

namespace gr {
  namespace nwr {

    correction_estimator_ff::sptr
    correction_estimator_ff::make(int inspection_length,
                                  int inspection_offset,
                                  float peak_ref,
                                  float trough_ref,
                                  const std::string &offset_corr_key,
                                  const std::string &scale_corr_key,
                                  bool scale_eob_zero,
                                  int timing_win_start,
                                  int timing_win_end,
                                  const std::string &time_est_key,
                                  const std::string &clock_est_key,
                                  const std::string &sob_key,
                                  const std::string &eob_key)
    {
      return gnuradio::get_initial_sptr
        (new correction_estimator_ff_impl(inspection_length, inspection_offset,
                                          peak_ref, trough_ref,
                                          offset_corr_key, scale_corr_key,
                                          scale_eob_zero,
                                          timing_win_start, timing_win_end,
                                          time_est_key, clock_est_key,
                                          sob_key, eob_key));
    }

    correction_estimator_ff_impl::correction_estimator_ff_impl(
                                          int inspection_length,
                                          int inspection_offset,
                                          float peak_ref,
                                          float trough_ref,
                                          const std::string &offset_corr_key,
                                          const std::string &scale_corr_key,
                                          bool scale_eob_zero,
                                          int timing_win_start,
                                          int timing_win_end,
                                          const std::string &time_est_key,
                                          const std::string &clock_est_key,
                                          const std::string &sob_key,
                                          const std::string &eob_key)
      : gr::sync_block("correction_estimator_ff",
              gr::io_signature::make(1, 1, sizeof(float)),
              gr::io_signature::make(1, 1, sizeof(float))),
        d_inspection_len(inspection_length),
        d_inspection_offset(inspection_offset),
        d_peak_ref(peak_ref),
        d_trough_ref(trough_ref),
        d_timing_win_start(timing_win_start),
        d_timing_win_end(timing_win_end),
        d_offset_corr_key(pmt::intern(offset_corr_key)),
        d_scale_corr_key(pmt::intern(scale_corr_key)),
        d_time_est_key(pmt::intern(time_est_key)),
        d_clock_est_key(pmt::intern(clock_est_key)),
        d_sob_key(pmt::intern(sob_key)),
        d_eob_key(pmt::intern(eob_key)),
        d_eob_offset_corr(pmt::from_double(0.0)),
        d_eob_scale_corr(pmt::from_double(scale_eob_zero ? 0.0 : 1.0)),
        d_src_id(pmt::intern(alias())),
        d_tags()
    {
        set_output_multiple((d_inspection_offset + d_inspection_len) * 2);
    }

    correction_estimator_ff_impl::~correction_estimator_ff_impl()
    {
    }

    void
    correction_estimator_ff_impl::compute_corrections(const float *in,
                                                      double &offset_corr,
                                                      double &scale_corr)
    {
        int i;
        const float *bb = &in[d_inspection_offset];

        // Find the max peak and the min trough and their midpoint
        float bb_min = bb[0];
        float bb_max = bb[0];

        for (i = 1; i < d_inspection_len; i++) {
            bb_min = std::min(bb_min, bb[i]);
            bb_max = std::max(bb_max, bb[i]);
        } 
        float bb_mid = (bb_max + bb_min)/2.0f;

        // Find the peaks and troughs.
        std::vector<unsigned int> peaks;
        std::vector<unsigned int> troughs;
        for (i = 1; i < d_inspection_len - 1; i++) {
            if (bb[i] > bb[i-1] and
                bb[i] > bb[i+1] and
                bb[i] - bb_mid > (0.9f * (bb_max - bb_mid)))
                peaks.push_back(i);
            if (bb[i] < bb[i-1] and
                bb[i] < bb[i+1] and
                bb[i] - bb_mid < (0.9f * (bb_min - bb_mid)))
                troughs.push_back(i);
        }

        std::vector<unsigned int>::iterator it;
        float bb_max_avg = 0.0f;
        for (it = peaks.begin(), i = 0; it != peaks.end(); ++it, i++)
            bb_max_avg += bb[*it];
        if (bb_max_avg == 0.0f)
            bb_max_avg = bb_max;
        else
            bb_max_avg /= (float) i;

        float bb_min_avg = 0.0f;
        for (it = troughs.begin(), i = 0; it != troughs.end(); ++it, i++)
            bb_min_avg += bb[*it];
        if (bb_min_avg == 0.0f)
            bb_min_avg = bb_min;
        else
            bb_min_avg /= (float) i;

        // (bb_max_avg + offset_corr) * scale_corr = d_peak_ref
        // (bb_min_avg + offset_corr) * scale_corr = d_trough_ref
        // So after some algebra ...

        offset_corr = (d_trough_ref * bb_max_avg - d_peak_ref * bb_min_avg)
                      / (d_peak_ref - d_trough_ref);
        scale_corr = (d_peak_ref - d_trough_ref) / (bb_max_avg - bb_min_avg);
        return;
    }

    bool 
    correction_estimator_ff_impl::compute_timing_estimate(const float *in,
                                                          uint64_t &n,
                                                          double &fraction,
                                                          double &clock_period)
    {
        if (d_timing_win_start < 0 or
            d_timing_win_end < 0 or
            d_timing_win_start >= d_timing_win_end or
            d_timing_win_start > (d_inspection_offset + d_inspection_len) or
            d_timing_win_end > (d_inspection_offset + d_inspection_len))
            return false;

        unsigned int i, j, k, l;

        float in_min = in[d_timing_win_start];
        float in_max = in[d_timing_win_start];
        for (i = d_timing_win_start + 1; i <= d_timing_win_end; i++) {
            in_min = std::min(in_min, in[i]);
            in_max = std::max(in_max, in[i]);
        }
        float in_mid = (in_max + in_min)/2.0f;

        std::vector<unsigned int> peaks;
        std::vector<unsigned int> troughs;
        for (i = d_timing_win_start + 1; i < d_timing_win_end; i++) {
            if (in[i] > in[i-1] and
                in[i] > in[i+1] and
                in[i] - in_mid > (0.9f * (in_max - in_mid)))
            peaks.push_back(i);
            if (in[i] < in[i-1] and
                in[i] < in[i+1] and
                in[i] - in_mid < (0.9f * (in_min - in_mid)))
            troughs.push_back(i);
        }

        if (peaks.size() == 0 or
            troughs.size() == 0 or
            peaks[0] == troughs[0])
            return false;

        float f, g, h, d, e, r, s;
        if (peaks[0] < troughs[0]) {
            i = peaks[0];
            j = troughs[0];
        } else {
            i = troughs[0];
            j = peaks[0];
        }
        f = (-1.0f*in[i-1] + 0.0f*in[i] + 1.0f*in[i+1])
            / (in[i-1] + in[i] + in[i+1]);
        g = (-1.0f*in[j-1] + 0.0f*in[j] + 1.0f*in[j+1])
            / (in[j-1] + in[j] + in[j+1]);
        h = static_cast<float>(j) + g - (static_cast<float>(i) + f);

        n = static_cast<uint64_t>(i);
        fraction = static_cast<double>(f);
        clock_period = static_cast<double>(h);

        if (peaks.size() < 2 or troughs.size() < 2)
            return true;

        if (peaks[0] < troughs[0]) {
            k = peaks[1];
            l = troughs[1];
        } else {
            k = troughs[1];
            l = peaks[1];
        }
        d = (-1.0f*in[k-1] + 0.0f*in[k] + 1.0f*in[k+1])
            / (in[k-1] + in[k] + in[k+1]);
        e = (-1.0f*in[l-1] + 0.0f*in[l] + 1.0f*in[l+1])
            / (in[l-1] + in[l] + in[l+1]);
        r = static_cast<float>(k) + d - (static_cast<float>(j) + g);
        s = static_cast<float>(l) + e - (static_cast<float>(k) + d);
        clock_period = static_cast<double>((h+r+s)/3.0f);
        return true;
    }

    int
    correction_estimator_ff_impl::work(int noutput_items,
        gr_vector_const_void_star &input_items,
        gr_vector_void_star &output_items)
    {
        const float *in = (const float *) input_items[0];
        float *out = (float *) output_items[0];

        uint64_t nitems_rd = nitems_read(0);

        // Get all the input tags in offset order
        d_tags.clear();
        get_tags_in_range(d_tags, 0, nitems_rd, nitems_rd + noutput_items);
        std::sort(d_tags.begin(), d_tags.end(), tag_t::offset_compare);

        // N.B. we might break badly if SOB and EOB are marked on the same
        // sample offset.  Garbage in, garbage out...

        // Plan to process all of the items in this call to work()
        int idx = noutput_items;
        std::vector<tag_t>::iterator t;
        // Loop through all the tags
        for (t = d_tags.begin(); t != d_tags.end(); ++t) {
            if (pmt::eq(t->key, d_eob_key)) {
                // EOB gets marked with constant correction tags, indicating:
                // offset_corr => 0.0
                // scale_corr => 1.0 or 0.0
                add_item_tag(0, t->offset,
                             d_offset_corr_key,
                             d_eob_offset_corr,
                             d_src_id);
                add_item_tag(0, t->offset,
                             d_scale_corr_key,
                             d_eob_scale_corr,
                             d_src_id);
            } else if (pmt::eq(t->key, d_sob_key)) {
                // SOB
                idx = static_cast<int>(t->offset - nitems_rd);
                if (idx + d_inspection_offset + d_inspection_len - 1
                                                             >= noutput_items) {
                    // We don't have all of the samples that we wish to
                    // process, from the start of the burst, in this call to
                    // work().  Bail out, processing all the samples before
                    // this one.  We'll have enough next time.
                    break;
                }

                double offset_corr = 0.0;
                double scale_corr = 1.0;
                compute_corrections(&in[idx], offset_corr, scale_corr);
                add_item_tag(0, t->offset,
                             d_offset_corr_key,
                             pmt::from_double(offset_corr),
                             d_src_id);
                add_item_tag(0, t->offset,
                             d_scale_corr_key,
                             pmt::from_double(scale_corr),
                             d_src_id);

                uint64_t n = 0;
                double fraction = 0.0;
                double clk_period = 0.0;
                if (compute_timing_estimate(&in[idx], n, fraction, clk_period)){
                    add_item_tag(0, t->offset + n,
                                 d_time_est_key,
                                 pmt::from_double(fraction),
                                 d_src_id);
                    add_item_tag(0, t->offset + n,
                                 d_clock_est_key,
                                 pmt::make_tuple(pmt::from_double(fraction),
                                                 pmt::from_double(clk_period)),
                                 d_src_id);
                }

                // Plan to process the rest of the items in this call to work()
                idx = noutput_items;
            }
        }

        // Propagate input to output
        memcpy(out, in, sizeof(float) * idx);
        return idx;
    }

  } /* namespace nwr */
} /* namespace gr */

