/* -*- c++ -*- */
/*
 * Copyright (C) 2016  Andy Walls <awalls.cx18@gmail.com>
 *
 * This file was automatically generated by gr_modtool from GNU Radio
 *
 * This file was automatically generated from a template incorporating
 * data input by Andy Walls and later hand edited by Andy Walls.
 * See http://www.gnu.org/licenses/gpl-faq.en.html#GPLOutput .
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include "same_burst_decoder_impl.h"

namespace gr {
  namespace nwr {

    same_burst_decoder::sptr
    same_burst_decoder::make(const std::string &sob_key,
                             const std::string &eob_key)
    {
      return gnuradio::get_initial_sptr
        (new same_burst_decoder_impl(sob_key, eob_key));
    }

    same_burst_decoder_impl::same_burst_decoder_impl(const std::string &sob_key,
                                                     const std::string &eob_key)
      : gr::sync_block("same_burst_decoder",
              gr::io_signature::make(1, 1, sizeof(float)),
              gr::io_signature::make(0, 0, 0)),
        d_sob_key(pmt::intern(sob_key)),
        d_eob_key(pmt::intern(eob_key)),
        d_printable_key(pmt::intern("printable")),
        d_bytes_key(pmt::intern("bytes")),
        d_hard_bits_key(pmt::intern("hard_bits")),
        d_soft_bits_key(pmt::intern("soft_bits")),
        d_soft_bits(),
        d_hard_bits(),
        d_bytes(),
        d_printable_str(),
        d_tags(),
        d_in_burst(false)
    {
        message_port_register_out(d_printable_key);
        message_port_register_out(d_bytes_key);
        message_port_register_out(d_hard_bits_key);
        message_port_register_out(d_soft_bits_key);

        d_soft_bits.reserve(MAX_BITS);
        d_hard_bits.reserve(MAX_BITS);
        d_bytes.reserve(MAX_BYTES);
        d_printable_str.reserve(MAX_BYTES - PREAMBLE_BYTES);
    }

    same_burst_decoder_impl::~same_burst_decoder_impl()
    {
    }

    void
    same_burst_decoder_impl::clear()
    {
        d_printable_str.clear();
        d_bytes.clear();
        d_hard_bits.clear();
        d_soft_bits.clear();
    }

    void
    same_burst_decoder_impl::output_messages()
    {
        message_port_pub(d_printable_key,
                         pmt::string_to_symbol(d_printable_str));

        message_port_pub(d_bytes_key,
                         pmt::cons(pmt::PMT_NIL,
                                   pmt::init_u8vector(d_bytes.size(),
                                                      d_bytes)));

        message_port_pub(d_hard_bits_key,
                         pmt::cons(pmt::PMT_NIL,
                                   pmt::init_u8vector(d_hard_bits.size(),
                                                      d_hard_bits)));

        message_port_pub(d_soft_bits_key,
                         pmt::cons(pmt::PMT_NIL,
                                   pmt::init_f32vector(d_soft_bits.size(),
                                                       d_soft_bits)));
    }

    bool 
    same_burst_decoder_impl::process_bits()
    {
        // We want to find the 4 header bytes and we'll allow
        // bytes of the preamble to be missing
        if (d_hard_bits.size() < (PREAMBLE_BYTES/2 + HEADER_BYTES) * 8)
            return false;

        // Find the header bytes and figure out our bit alignment
        uint32_t fourbytes = 0;
        int bit_idx;
        int bit_align;
        int preamble_bytes;
        bool hdr_found = false;
        for (bit_idx = 0; bit_idx < d_hard_bits.size(); bit_idx++) {
            fourbytes >>= 1;
            if (d_hard_bits[bit_idx])
                fourbytes |= 0x80000000;
            if (fourbytes == 0x435a435a or     // CZCZ, ZCZC in rev byte order
                fourbytes == 0x4e4e4e4e    ) { // NNNN, NNNN in rev byte order
                // Found last bit of full header at bit_idx
                bit_align = (bit_idx + 1) % 8;
                preamble_bytes = (bit_idx - 31) / 8;
                hdr_found = true;
            }
        }

        if (hdr_found == false)
            return false;

        // Read in the bytes
        uint8_t byte = 0;
        int bit_count = 0;
        for (bit_idx = bit_align; bit_idx < d_hard_bits.size(); bit_idx++) {
            byte >>= 1;
            if (d_hard_bits[bit_idx])
                byte |= 0x80;
            bit_count++;
            if (bit_count == 8) {
                d_bytes.push_back(byte);
                bit_count = 0;
            }
        }

        // Assemble the readable string
        for (int i = preamble_bytes; i < d_bytes.size(); i++)
            if (isprint(d_bytes[i]))
                d_printable_str.push_back(d_bytes[i]);

        return true;
    }

    void
    same_burst_decoder_impl::process_input(const float *in,
                                           int start, int bound)
    {
        for (int i = start; d_in_burst and i < bound; i++) {
            d_soft_bits.push_back(in[i]);
            d_hard_bits.push_back(slice(in[i]));
            if (d_soft_bits.size() >= MAX_BITS) {
                if (process_bits())
                    output_messages();
                clear();
                d_in_burst = false;
            }
        }
    }

    int
    same_burst_decoder_impl::work(int noutput_items,
        gr_vector_const_void_star &input_items,
        gr_vector_void_star &output_items)
    {
        const float *in = (const float *) input_items[0];

        uint64_t nitems_rd = nitems_read(0);

        // Get all the input tags in offset order
        d_tags.clear();
        get_tags_in_range(d_tags, 0, nitems_rd, nitems_rd + noutput_items);
        std::sort(d_tags.begin(), d_tags.end(), tag_t::offset_compare);

        // N.B. we might break badly if SOB and EOB are marked on the same
        // sample offset.  Garbage in, garbage out...

        int idx = 0;
        int tidx;
        std::vector<tag_t>::iterator t;

        // Loop through all the tags
        for (t = d_tags.begin(); t != d_tags.end(); ++t) {
            if (pmt::eq(t->key, d_eob_key)) {
                tidx = static_cast<int>(t->offset - nitems_rd);
                process_input(in, idx, tidx);
                idx = tidx;
                d_in_burst = false;
            } else if (pmt::eq(t->key, d_sob_key)) {
                // Handle a missing EOB tag as robustly as we can.
                tidx = static_cast<int>(t->offset - nitems_rd);
                process_input(in, idx, tidx);

                // We'll handle the input from the SOB, when we find the next
                // SOB or EOB tag, or when there are none of those tags left
                // in this call to work.
                idx = tidx;
                d_in_burst = true;
            }
        }

        process_input(in, idx, noutput_items);

        return noutput_items;
    }

  } /* namespace nwr */
} /* namespace gr */

