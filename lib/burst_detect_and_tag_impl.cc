/* -*- c++ -*- */
/*
 * Copyright (C) 2016  Andy Walls <awalls.cx18@gmail.com>
 *
 * This file was automatically generated by gr_modtool from GNU Radio
 *
 * This file was automatically generated from a template incorporating
 * data input by Andy Walls and subsequently hand edited by Andy Walls.
 * See http://www.gnu.org/licenses/gpl-faq.en.html#GPLOutput .
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include <volk/volk.h>
#include "burst_detect_and_tag_impl.h"

namespace gr {
  namespace nwr {

    burst_detect_and_tag::sptr
    burst_detect_and_tag::make(size_t item_size,
                               float samp_rate,
                               float thresh_db,
                               float init_floor_est,
                               float declare_dur,
                               float max_dur,
                               float sob_amp_frac,
                               const std::string &sob_key,
                               const std::string &eob_key,
                               float eob_delay,
                               float guard_interval)
    {
      return gnuradio::get_initial_sptr
        (new burst_detect_and_tag_impl(item_size, samp_rate, thresh_db,
                                       init_floor_est, declare_dur, max_dur,
                                       sob_amp_frac, sob_key, eob_key,
                                       eob_delay, guard_interval));
    }

    burst_detect_and_tag_impl::burst_detect_and_tag_impl(size_t item_size,
                                                         float samp_rate,
                                                         float thresh_db,
                                                         float init_floor_est,
                                                         float declare_dur,
                                                         float max_dur,
                                                         float sob_amp_frac,
                                                         const std::string &sob_key,
                                                         const std::string &eob_key,
                                                         float eob_delay,
                                                         float guard_interval)
      : gr::sync_block("burst_detect_and_tag",
              gr::io_signature::make2(2, 2, item_size, sizeof(float)),
              gr::io_signature::make(1, 1, item_size)),
        d_item_size(item_size),
        d_samp_rate(samp_rate),
        d_threshold(std::pow(10.0, thresh_db/10.0)),
        d_floor_mutex(),
        d_floor(init_floor_est),
        d_declare_len(lround(samp_rate * declare_dur)),
        d_max_len(lround(samp_rate * max_dur)),
        d_sob_amp_frac(sob_amp_frac),
        d_eob_smpl_delay(lround(d_samp_rate * eob_delay)),
        d_guard_smpl_intvl(lround(d_samp_rate * guard_interval)),
        d_sob_key(pmt::intern(sob_key)),
        d_eob_key(pmt::intern(eob_key)),
        d_src_id(pmt::intern(alias())),
        d_rx_time_key(pmt::intern("rx_time")),
        d_msg_port(pmt::mp("floor_msg")),
        d_state(SEARCH),
        d_burst_len(0),
        d_eob_len(0),
        d_last_eob_offset(0),
        d_tags(),
        d_ref_time(0, 0.0),
        d_ref_time_offset(0)
    {
        const int alignment_multiple = volk_get_alignment() / sizeof(float);
        set_alignment(std::max(1, alignment_multiple));

        // Hopefully this reduces the amount of instances where we don't
        // process all items due to the noutput items ending in the declaration
        // window.
        if (d_declare_len > 0)
            set_output_multiple(d_declare_len * 2);

        // We only want tags from input 0 to output 0 to propagate,
        // so we do it ourselves.
        set_tag_propagation_policy(TPP_DONT);

        // I want to use volk routines, but I don't want to deal with
        // some unbounded max number of output items
        set_max_noutput_items(std::max(64*1024, d_declare_len*2));
        d_result = (float *)
                   volk_malloc(sizeof(float)*std::max(64*1024, d_declare_len*2),
                               volk_get_alignment());

        if (d_eob_smpl_delay <= 0)
            d_eob_smpl_delay = 1;

        message_port_register_in(d_msg_port);
        set_msg_handler(d_msg_port, boost::bind(&burst_detect_and_tag_impl::msg_handler, this, _1));
    }

    burst_detect_and_tag_impl::~burst_detect_and_tag_impl()
    {
        volk_free(d_result);
    }

    void
    burst_detect_and_tag_impl::msg_handler(pmt::pmt_t msg)
    {
        float tmp = pmt::to_float(msg);
        if (tmp > 0.0f) {
            gr::thread::scoped_lock lock(d_floor_mutex);
            d_floor = tmp;
        }
    }

    int 
    burst_detect_and_tag_impl::calc_sob_index(int first, int last)
    {
        int i;

        float wmin = d_result[first];
        float wmax = wmin;

        for (i = first + 1; i <= last; ++i) {
            wmin = std::min(wmin, d_result[i]);
            wmax = std::max(wmax, d_result[i]);
        }

        float thresh = wmin + (wmax - wmin) * d_sob_amp_frac;

        for (i = first; i < last; ++i)
            if (d_result[i] >= thresh)
                break;
        return i;
    }

    bool
    burst_detect_and_tag_impl::parse_time_tag(const tag_t &time_tag,
                                              uint64_t &seconds,
                                              double &subseconds)
    {
        if (not pmt::is_tuple(time_tag.value) or
                pmt::length(time_tag.value) != 2)
            return false;

        pmt::pmt_t secs = pmt::tuple_ref(time_tag.value, 0);
        pmt::pmt_t frac_secs = pmt::tuple_ref(time_tag.value, 1);

        if (not pmt::is_uint64(secs) or not pmt::is_real(frac_secs))
            return false;

        seconds = pmt::to_uint64(secs);
        subseconds = pmt::to_double(frac_secs);
        return true;
    }

    void
    burst_detect_and_tag_impl::update_ref_time(uint64_t offset)
    {
        std::vector<tag_t>::iterator t;
        uint64_t secs;
        double frac_secs;

        // Advance time reference to the latest received time tag before
        // this sample offset.
        for (t = d_tags.begin();
             t != d_tags.end() and t->offset <= offset; ++t) {
            if (not pmt::eq(t->key, d_rx_time_key))
                continue;
            if (parse_time_tag(*t, secs, frac_secs)) {
                d_ref_time = ::uhd::time_spec_t(secs, frac_secs);
                d_ref_time_offset = t->offset;
            }
        }
    }

    pmt::pmt_t
    burst_detect_and_tag_impl::compute_sample_time(uint64_t offset)
    {
        // Advance time reference to the latest received time tag before
        // this sample offset.
        update_ref_time(offset);

        // Compute the time for this sample offset
        long long ticks = static_cast<long long>(offset - d_ref_time_offset);
        ::uhd::time_spec_t tmp(
               d_ref_time + ::uhd::time_spec_t::from_ticks(ticks, d_samp_rate));

        return pmt::make_tuple(pmt::from_uint64(tmp.get_full_secs()),
                               pmt::from_double(tmp.get_frac_secs()));
    }

    int
    burst_detect_and_tag_impl::find_next_above_thresh(const int start,
                                                      const int end)
    {
        int lower_bnd = start;
        int upper_bnd = end;
        int midpt;

        // Binary search
        do {
            midpt = (lower_bnd + upper_bnd)/2;
            if (d_result[midpt] > d_threshold)
                upper_bnd = midpt;
            else
                lower_bnd = midpt + 1;
        } while (lower_bnd != upper_bnd);

        return lower_bnd;
    }

    int
    burst_detect_and_tag_impl::find_next_at_or_below_thresh(const int start,
                                                            const int end)
    {
        int lower_bnd = start;
        int upper_bnd = end;
        int midpt;

        // Binary search
        do {
            midpt = (lower_bnd + upper_bnd)/2;
            if (d_result[midpt] > d_threshold)
                lower_bnd = midpt + 1;
            else
                upper_bnd = midpt;
        } while (lower_bnd != upper_bnd);

        return lower_bnd;
    }

    int
    burst_detect_and_tag_impl::work(int noutput_items,
              gr_vector_const_void_star &input_items,
              gr_vector_void_star &output_items)
    {
        const void *in = input_items[0];
        const float *mag = (const float *) input_items[1];
        void *out = output_items[0];

        // If don't have the minimum amount of items to make a declaration,
        // wait for more.
        if (d_state == SEARCH and d_declare_len > noutput_items)
            return 0;

        float floor;
        {
            gr::thread::scoped_lock lock(d_floor_mutex);
            floor = d_floor;
        }
        volk_32f_s32f_multiply_32f(d_result, mag, 1.0f/floor, noutput_items);

        uint64_t nitems_wr = nitems_written(0);
        d_tags.clear();
        get_tags_in_range(d_tags, 0, nitems_wr, nitems_wr + noutput_items);
        std::sort(d_tags.begin(), d_tags.end(), tag_t::offset_compare);

        bool quit = false;
        int win_len = 0;
        int win_sidx = 0;
        int win_eidx = 0;
        int peek_idx;
        int iidx = 0;
        while (iidx < noutput_items) {
            switch (d_state) {
            case SEARCH:
                if (d_result[iidx] > d_threshold) {
                    // We broke threshold
                    if ((iidx + d_declare_len) > noutput_items) {
                        // Quit if we might have a start of burst and we can't
                        // make a declaration in this call to work.
                        quit = true;
                        break;
                    }
                    // We might have a start of burst, so change state
                    // and find out if we will meet minimum burst length.
                    win_len = 0;
                    d_state = WINDOW;
                    continue;
                }
                // else, keep searching.

                // Skip ahead if there is no burst in sight.
                peek_idx = iidx + d_declare_len;
                if (peek_idx >= noutput_items)
                    peek_idx = noutput_items - 1;
                if (d_result[peek_idx] <= d_threshold)
                    iidx = peek_idx;
                else {
                    iidx = find_next_above_thresh(iidx, peek_idx);
                    continue;
                }
                break;

            case WINDOW:
                // Start search at end of window to skip false alarms
                win_eidx = iidx;
                win_sidx = win_eidx + d_declare_len - 1;
                if (win_sidx > noutput_items)
                    win_sidx = noutput_items - 1;
                for (int w = win_sidx; w >= win_eidx; --w) {
                    if (d_result[w] <= d_threshold) {
                        // Too short. No burst. Go back to searching.
                        iidx = w + 1;
                        d_state = SEARCH;
                        continue;
                    }
                    // Samples in the window are staying above threshold
                    ++win_len;
                    if (win_len >= d_declare_len) {

                        // We declare a start of burst.  Go look for end of burst.
                        uint64_t sob_offset = nitems_wr + calc_sob_index(w, win_sidx);
                        add_item_tag(0, sob_offset, d_sob_key,
                                     compute_sample_time(sob_offset), d_src_id);
                        d_burst_len = win_len;
                        d_state = BURST;
                        break;
                    } // else, keep monitoring for end of declaration window
                }
                iidx = win_sidx;
                break;

            case BURST:
                if (d_result[iidx] <= d_threshold)
                    ++d_eob_len;
                else
                    d_eob_len = 0;
                if (d_eob_len >= d_eob_smpl_delay ||
                    d_burst_len >= d_max_len) {
                    // End of burst.  Go back to searching.
                    uint64_t eob_offset = nitems_wr + iidx;
                    add_item_tag(0, eob_offset, d_eob_key,
                                 compute_sample_time(eob_offset), d_src_id);
                    d_burst_len = 0;
                    d_eob_len = 0;
                    d_last_eob_offset = nitems_wr + iidx;
                    d_state = GUARD;
                    break;
                }
                // Samples in the window are staying above threshold
                ++d_burst_len;

                // Skip ahead if there is no end of burst in sight.
                peek_idx = iidx +
                           std::min(static_cast<int>(d_declare_len),
                                    static_cast<int>(d_max_len - d_burst_len));
                if (peek_idx >= noutput_items)
                    peek_idx = noutput_items - 1;
                if (d_result[peek_idx] > d_threshold) {
                    d_burst_len += peek_idx - iidx;
                    iidx = peek_idx;
                } else {
                    peek_idx = find_next_at_or_below_thresh(iidx, peek_idx);
                    d_burst_len += peek_idx - 1 - iidx;
                    iidx = peek_idx;
                    continue;
                }
                break;
            case GUARD:
                if (d_guard_smpl_intvl < nitems_wr + iidx - d_last_eob_offset) {
                    d_state = SEARCH;
                }
                else {
                    peek_idx = iidx + d_guard_smpl_intvl -
                               (nitems_wr + iidx - d_last_eob_offset);
                    if (peek_idx >= noutput_items)
                        peek_idx = noutput_items - 1;
                    if (peek_idx > iidx)
                        iidx = peek_idx;
                }
                break;
            }
            if (quit)
                break;
            ++iidx;
        }

        if (iidx == 0)
            return iidx;

        // Propagate input to output
        memcpy(out, in, d_item_size * iidx);

        // Advance time reference to the latest received time tag before
        // this sample offset.
        update_ref_time(nitems_wr + iidx - 1);

        // Propagate incoming tags manually and only for first input/output
        std::vector<tag_t>::iterator t;
        uint64_t tmp_max = nitems_wr + iidx;
        for (t = d_tags.begin(); t != d_tags.end() and t->offset < tmp_max; ++t)
            add_item_tag(0, *t);

        // Tell runtime system how many output items we produced.
        return iidx;
    }

  } /* namespace nwr */
} /* namespace gr */

